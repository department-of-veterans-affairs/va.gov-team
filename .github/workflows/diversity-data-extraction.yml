# .github/workflows/diversity-data-extraction.yml
#
# Purpose: Extract participant demographic data from research findings reports
# and aggregate for quarterly diversity reporting.  Runs on new findings commits
# and weekly for aggregation.
#
# Repository: va.gov-team (with sparse checkout)
# Reports pushed to: va.gov-research-repository/reports/quarterly-reports/diversity-reports/

name: Diversity Data Extraction

on: 
  push:
    paths:
      - 'products/**/research/**/*findings*.md'
      - 'teams/**/research/**/*findings*.md'
      - '!**/*.doc'
      - '!**/*.docx'
      - '!**/*.pptx'
      - '!**/*.pdf'
  schedule:
    # Run weekly on Mondays at 8:00 AM ET (13:00 UTC) for aggregation
    - cron: '0 13 * * 1'
  workflow_dispatch: 
    inputs:
      full_scan:
        description: 'Run full repository scan (slow)'
        required: false
        default: 'false'
        type: boolean
      dry_run:
        description: 'Test run - do not push to research repository'
        required: false
        default: 'false'
        type: boolean

jobs:
  extract-diversity-data: 
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps: 
      - name: Sparse Checkout - Research Findings Only
        if: ${{ github.event.inputs.full_scan != 'true' }}
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            products/**/research
            teams/**/research
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      
      - name: Full Checkout
        if: ${{ github.event.inputs.full_scan == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: 
          node-version: '20'
      
      - name: Install dependencies
        run: |
          npm install js-yaml glob
      
      - name: Extract demographic data from findings
        id: extract
        uses: actions/github-script@v7
        with: 
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const globModule = require('glob');
            
            // Helper function to safely parse integers
            const toInt = (value) => {
              const parsed = parseInt(value, 10);
              return isNaN(parsed) ? 0 : parsed;
            };
            
            // Helper function to encode file path for URLs (encode spaces and special chars, preserve slashes)
            const encodeFilePath = (filePath) => {
              return filePath.split('/').map(segment => encodeURIComponent(segment)).join('/');
            };
            
            // Helper function to check if a value is a placeholder/template value
            const isPlaceholder = (value) => {
              if (!value || typeof value !== 'string') return true;
              const placeholders = [
                'YYYY-MM-DD',
                'yyyy-mm-dd',
                '[Study]',
                '[study]',
                '[Team]',
                '[team]',
                '[Product]',
                '[product]',
                'TBD',
                'tbd',
                'N/A',
                'n/a',
                'TODO',
                'todo',
                'PLACEHOLDER',
                'placeholder'
              ];
              return placeholders.some(p => value.includes(p));
            };
            
            // Helper function to check if a key is a valid demographic key (not a numeric index)
            const isValidDemographicKey = (key) => {
              // Skip numeric keys (from arrays), internal properties, and rate calculations
              if (/^\d+$/.test(key)) return false;
              if (key.endsWith('_rate')) return false;
              if (key === 'rate') return false;
              return true;
            };
            
            // Helper function to validate and parse date
            const parseDate = (dateStr) => {
              if (!dateStr || dateStr === 'unknown' || isPlaceholder(dateStr)) {
                return null;
              }
              // Try to parse various date formats
              const date = new Date(dateStr);
              if (!isNaN(date.getTime())) {
                return date;
              }
              // Handle formats like "08-2025" (MM-YYYY)
              const mmYyyyMatch = dateStr.match(/^(\d{1,2})-(\d{4})$/);
              if (mmYyyyMatch) {
                return new Date(`${mmYyyyMatch[2]}-${mmYyyyMatch[1].padStart(2, '0')}-01`);
              }
              return null;
            };
            
            // Helper function to format date for display
            const formatDate = (dateStr) => {
              const parsed = parseDate(dateStr);
              if (!parsed) {
                return null;
              }
              return parsed.toISOString().split('T')[0];
            };
            
            // Helper function to check if frontmatter has real data (not just template)
            const hasCompletedData = (frontMatter) => {
              // Must have a valid date (not a placeholder)
              const hasValidDate = frontMatter.date && !isPlaceholder(frontMatter.date) && parseDate(frontMatter.date) !== null;
              
              // Must have participants count > 0
              const hasParticipants = toInt(frontMatter.participants_total) > 0;
              
              // Must have either valid date OR participants to be considered complete
              // But ideally should have both - require at least one solid indicator
              if (!hasValidDate && !hasParticipants) {
                return false;
              }
              
              // Check if title is a placeholder
              if (frontMatter.title && isPlaceholder(frontMatter.title)) {
                // If title is placeholder, we need both date AND participants
                return hasValidDate && hasParticipants;
              }
              
              // If we have a real title, having either date or participants is enough
              return hasValidDate || hasParticipants;
            };
            
            // Helper to format label for display (convert snake_case to Title Case)
            const formatLabel = (key) => {
              return key
                .replace(/_/g, ' ')
                .replace(/\b\w/g, c => c.toUpperCase())
                .replace(/^At /i, 'AT ')
                .replace(/ At /gi, ' AT ')
                .replace(/^Va /i, 'VA ')
                .replace(/ Va /gi, ' VA ');
            };
            
            // Helper to safely extract object data, skipping arrays and invalid entries
            const safeExtractObject = (data) => {
              if (!data || typeof data !== 'object' || Array.isArray(data)) {
                return {};
              }
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (isValidDemographicKey(key) && typeof value === 'number') {
                  result[key] = value;
                } else if (isValidDemographicKey(key) && typeof value === 'string') {
                  const numVal = toInt(value);
                  if (!isNaN(numVal)) {
                    result[key] = numVal;
                  }
                }
              }
              return result;
            };
            
            // Find all findings files (only .md files, excluding binary formats)
            const files = await globModule.glob('**/research/**/*findings*.md', {
              ignore: ['node_modules/**', '.git/**', '**/*.doc', '**/*.docx', '**/*.pptx', '**/*.pdf']
            });
            
            console.log(`Found ${files.length} research findings files`);
            
            const allDemographics = [];
            const skippedFiles = [];
            const errors = [];
            
            // Repository info for generating URLs
            const repoOwner = 'department-of-veterans-affairs';
            const repoName = 'va.gov-team';
            const defaultBranch = 'master';
            
            for (const file of files) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                
                // Extract YAML front matter
                const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
                if (!yamlMatch) {
                  continue; // No YAML front matter
                }
                
                const frontMatter = yaml.load(yamlMatch[1]);
                
                // Check if demographics data exists
                if (frontMatter.demographics || frontMatter.participants_total) {
                  
                  // Validate that this is completed data, not a template
                  if (!hasCompletedData(frontMatter)) {
                    skippedFiles.push({ file, reason: 'Incomplete or template frontmatter' });
                    console.log(`Skipping ${file}: Incomplete or template frontmatter`);
                    continue;
                  }
                  
                  // Generate GitHub URL for this file with proper encoding
                  const encodedPath = encodeFilePath(file);
                  const fileUrl = `https://github.com/${repoOwner}/${repoName}/blob/${defaultBranch}/${encodedPath}`;
                  
                  // Get a clean title - skip placeholder titles
                  let title = frontMatter.title || '';
                  if (!title || isPlaceholder(title)) {
                    // Extract a better title from the file path
                    const pathParts = file.split('/');
                    const fileName = pathParts.pop().replace('.md', '').replace(/-/g, ' ');
                    const folderName = pathParts.pop() || '';
                    title = folderName.replace(/-/g, ' ').replace(/^\d{4}-\d{2}\s*/, '') || fileName;
                    // Capitalize first letter of each word
                    title = title.replace(/\b\w/g, c => c.toUpperCase());
                  }
                  
                  const record = {
                    file: file,
                    file_url: fileUrl,
                    date: frontMatter.date || 'unknown',
                    date_parsed: parseDate(frontMatter.date),
                    date_formatted: formatDate(frontMatter.date),
                    product: frontMatter.product || 'unknown',
                    team: frontMatter.team || 'unknown',
                    title: title,
                    participants_total: toInt(frontMatter.participants_total),
                    demographics: frontMatter.demographics || {},
                    devices_used: frontMatter.devices_used || {},
                    methodology: frontMatter.methodology || []
                  };
                  
                  allDemographics.push(record);
                }
              } catch (err) {
                errors.push({ file, error: err.message });
              }
            }
            
            console.log(`Extracted demographics from ${allDemographics.length} files`);
            console.log(`Skipped ${skippedFiles.length} files with incomplete data`);
            console.log(`Errors: ${errors.length}`);
            
            // Aggregate data with all demographic categories
            const aggregated = {
              extraction_date: new Date().toISOString(),
              total_studies: allDemographics.length,
              total_participants: 0,
              
              // Participant types
              participant_types: {
                veterans: 0,
                service_members: 0,
                caregivers: 0,
                dependents: 0,
                VA_staff: 0
              },
              
              // Devices
              devices: {
                desktop: 0,
                tablet: 0,
                smartphone: 0,
                assistive_technology: 0
              },
              
              // Age groups
              age: {
                '25-34': 0,
                '35-44': 0,
                '45-54': 0,
                '55-64': 0,
                '65+': 0,
                'unknown': 0
              },
              
              // Education levels
              education: {
                high_school: 0,
                some_college: 0,
                associates: 0,
                bachelors: 0,
                masters: 0,
                doctorate: 0,
                unknown: 0
              },
              
              // Location
              location: {
                urban: 0,
                rural: 0,
                unknown: 0
              },
              
              // Race/ethnicity
              race: {
                white: 0,
                black: 0,
                hispanic: 0,
                biracial: 0,
                asian: 0,
                native: 0
              },
              
              // Disability and assistive technology
              disability: {
                cognitive: 0,
                AT_beginner: 0,
                AT_advanced: 0,
                screen_reader_desktop: 0,
                screen_reader_mobile: 0,
                magnification_zoom: 0,
                speech_input: 0,
                hearing_aids: 0,
                sighted_keyboard: 0,
                captions: 0
              },
              
              // AT inclusion summary
              at_inclusion: {
                studies_with_at: 0,
                total_at_participants: 0
              },
              
              // Study list
              studies: allDemographics.map(r => ({
                title: r.title,
                file: r.file,
                url: r.file_url,
                date: r.date_formatted || r.date,
                product: r.product,
                team: r.team,
                participants: r.participants_total
              })),
              
              skipped_files: skippedFiles
            };
            
            // Aggregate all data
            for (const record of allDemographics) {
              aggregated.total_participants += toInt(record.participants_total);
              
              // Participant types (top-level demographics)
              for (const type of ['veterans', 'service_members', 'caregivers', 'dependents', 'VA_staff']) {
                if (record.demographics?.[type] !== undefined) {
                  aggregated.participant_types[type] += toInt(record.demographics[type]);
                }
              }
              
              // Devices - safely extract
              const deviceData = safeExtractObject(record.devices_used);
              for (const device of ['desktop', 'tablet', 'smartphone', 'assistive_technology']) {
                if (deviceData[device] !== undefined) {
                  aggregated.devices[device] += toInt(deviceData[device]);
                }
              }
              
              // AT inclusion tracking
              const atCount = toInt(deviceData.assistive_technology || 0);
              if (atCount > 0) {
                aggregated.at_inclusion.studies_with_at++;
                aggregated.at_inclusion.total_at_participants += atCount;
              }
              
              // Age groups - safely extract and aggregate
              const ageData = safeExtractObject(record.demographics?.age);
              for (const [key, value] of Object.entries(ageData)) {
                if (aggregated.age.hasOwnProperty(key)) {
                  aggregated.age[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.age[key] = toInt(value);
                }
              }
              
              // Education - safely extract and aggregate
              const educationData = safeExtractObject(record.demographics?.education);
              for (const [key, value] of Object.entries(educationData)) {
                if (aggregated.education.hasOwnProperty(key)) {
                  aggregated.education[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.education[key] = toInt(value);
                }
              }
              
              // Location - safely extract and aggregate
              const locationData = safeExtractObject(record.demographics?.location);
              for (const [key, value] of Object.entries(locationData)) {
                if (aggregated.location.hasOwnProperty(key)) {
                  aggregated.location[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.location[key] = toInt(value);
                }
              }
              
              // Race - safely extract and aggregate
              const raceData = safeExtractObject(record.demographics?.race);
              for (const [key, value] of Object.entries(raceData)) {
                if (aggregated.race.hasOwnProperty(key)) {
                  aggregated.race[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.race[key] = toInt(value);
                }
              }
              
              // Disability - safely extract and aggregate
              const disabilityData = safeExtractObject(record.demographics?.disability);
              for (const [key, value] of Object.entries(disabilityData)) {
                if (aggregated.disability.hasOwnProperty(key)) {
                  aggregated.disability[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.disability[key] = toInt(value);
                }
              }
            }
            
            // Calculate rates (store separately, not in the main objects)
            let atInclusionRate = '0.0%';
            if (aggregated.total_studies > 0) {
              atInclusionRate = (
                (aggregated.at_inclusion.studies_with_at / aggregated.total_studies) * 100
              ).toFixed(1) + '%';
            }
            
            let ruralRate = null;
            const locationTotal = aggregated.location.rural + aggregated.location.urban;
            if (locationTotal > 0) {
              ruralRate = ((aggregated.location.rural / locationTotal) * 100).toFixed(1);
            }
            
            // Output results
            core.setOutput('aggregated', JSON.stringify(aggregated, null, 2));
            core.setOutput('study_count', allDemographics.length);
            core.setOutput('participant_count', aggregated.total_participants);
            core.setOutput('skipped_count', skippedFiles.length);
            
            // Generate date-stamped filename
            const dateStamp = new Date().toISOString().split('T')[0];
            core.setOutput('date_stamp', dateStamp);
            
            // Create summary artifact - build it as an array then join
            const summaryLines = [
              '# Diversity Data Extraction Summary',
              '',
              '**Extraction Date:** ' + aggregated.extraction_date,
              '',
              '## Overview',
              '- **Total Studies:** ' + aggregated.total_studies,
              '- **Total Participants:** ' + aggregated.total_participants,
              '- **Files Skipped (incomplete data):** ' + skippedFiles.length,
              '',
              '---',
              '',
              '## Participant Types',
              ''
            ];
            
            // Participant types
            for (const [key, value] of Object.entries(aggregated.participant_types)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            // Devices Used
            summaryLines.push('## Devices Used', '');
            for (const [key, value] of Object.entries(aggregated.devices)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            // AT Inclusion
            summaryLines.push('## Assistive Technology Inclusion', '');
            summaryLines.push(`- **Studies with AT Users:** ${aggregated.at_inclusion.studies_with_at} (${atInclusionRate})`);
            summaryLines.push(`- **Total AT Participants:** ${aggregated.at_inclusion.total_at_participants}`);
            summaryLines.push('');
            
            // Age Distribution
            summaryLines.push('## Age Distribution', '');
            for (const [key, value] of Object.entries(aggregated.age)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${key}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            // Education Levels
            summaryLines.push('## Education Levels', '');
            for (const [key, value] of Object.entries(aggregated.education)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            // Location
            summaryLines.push('## Geographic Location', '');
            for (const [key, value] of Object.entries(aggregated.location)) {
              if (isValidDemographicKey(key)) {
                let rateStr = '';
                if ((key === 'rural' || key === 'urban') && locationTotal > 0) {
                  const rate = ((value / locationTotal) * 100).toFixed(1);
                  rateStr = ` (${rate}%)`;
                }
                summaryLines.push(`- **${formatLabel(key)}:** ${value}${rateStr}`);
              }
            }
            summaryLines.push('');
            
            // Race/Ethnicity
            summaryLines.push('## Race/Ethnicity', '');
            for (const [key, value] of Object.entries(aggregated.race)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            // Disability and Assistive Technology Details
            summaryLines.push('## Disability & Assistive Technology Details', '');
            for (const [key, value] of Object.entries(aggregated.disability)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            // Appendix
            summaryLines.push('---', '');
            summaryLines.push('## Appendix: Studies Included in This Report', '');
            
            // Sort studies by date (most recent first), with unknown/invalid dates at the end
            const sortedStudies = [...allDemographics].sort((a, b) => {
              if (!a.date_parsed && !b.date_parsed) return 0;
              if (!a.date_parsed) return 1;
              if (!b.date_parsed) return -1;
              return b.date_parsed - a.date_parsed;
            });
            
            // Add each study as a linked list item
            for (const study of sortedStudies) {
              const dateStr = study.date_formatted ? ` (${study.date_formatted})` : '';
              const participantStr = study.participants_total > 0 ? ` - ${study.participants_total} participants` : '';
              summaryLines.push(`- [${study.title}](${study.file_url})${dateStr}${participantStr}`);
            }
            
            const summary = summaryLines.join('\n');
            
            fs.writeFileSync('diversity-summary.md', summary);
            fs.writeFileSync('diversity-data.json', JSON.stringify(aggregated, null, 2));
      
      - name: Upload diversity data artifact
        uses: actions/upload-artifact@v4
        with: 
          name: diversity-data-${{ github.run_id }}
          path: |
            diversity-summary.md
            diversity-data.json
          retention-days: 90
      
      - name: Push reports to va.gov-research-repository
        if: ${{ github.event.inputs.dry_run != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.RESEARCH_REPO_TOKEN }}
        run: |
          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Clone the research repository
          git clone https://x-access-token:${GH_TOKEN}@github.com/department-of-veterans-affairs/va.gov-research-repository.git research-repo
          
          cd research-repo
          
          # Create reports directory structure if it doesn't exist
          mkdir -p reports/quarterly-reports/diversity-reports
          
          # Copy the generated reports with date-stamped names
          DATE_STAMP="${{ steps.extract.outputs.date_stamp }}"
          cp ../diversity-summary.md "reports/quarterly-reports/diversity-reports/diversity-summary-${DATE_STAMP}.md"
          cp ../diversity-data.json "reports/quarterly-reports/diversity-reports/diversity-data-${DATE_STAMP}.json"
          
          # Also maintain a "latest" copy for easy access
          cp ../diversity-summary.md "reports/quarterly-reports/diversity-reports/diversity-summary-latest.md"
          cp ../diversity-data.json "reports/quarterly-reports/diversity-reports/diversity-data-latest.json"
          
          # Create/update the reports README if it doesn't exist
          if [ ! -f "reports/quarterly-reports/diversity-reports/README.md" ]; then
            cat > reports/quarterly-reports/diversity-reports/README.md << 'EOF'
          # Diversity Reports

          This folder contains automatically generated diversity data reports from research findings.

          ## Report Files

          - `diversity-summary-latest.md` - Most recent summary report
          - `diversity-data-latest.json` - Most recent data in JSON format
          - Date-stamped versions (e.g., `diversity-summary-2026-01-27.md`) are retained for historical tracking

          ## Data Source

          These reports are automatically generated from research findings in the va.gov-team repository.
          They aggregate participant demographic data for quarterly diversity reporting.

          ## Update Schedule

          Reports are updated:
          - On every push to research findings files
          - Weekly on Mondays at 8:00 AM ET
          EOF
          fi
          
          # Check if there are changes to commit
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git add reports/
            git commit -m "Update diversity data reports - ${DATE_STAMP}

          Automated extraction from va.gov-team research findings.
          
          Studies analyzed: ${{ steps.extract.outputs.study_count }}
          Total participants: ${{ steps.extract.outputs.participant_count }}
          Skipped files: ${{ steps.extract.outputs.skipped_count }}
          
          Generated by: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            
            git push
            echo "Reports pushed successfully to va.gov-research-repository"
          fi
      
      - name: Dry run notice
        if: ${{ github.event.inputs.dry_run == 'true' }}
        run: |
          echo "::notice::DRY RUN - Reports were generated but NOT pushed to va.gov-research-repository"
          echo "## ðŸ§ª Dry Run Mode" >> $GITHUB_STEP_SUMMARY
          echo "Reports were generated and uploaded as artifacts but **not pushed** to va.gov-research-repository." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      
      - name: Post summary
        run: |
          cat diversity-summary.md >> $GITHUB_STEP_SUMMARY
