name: Validate Product Details

on:
  pull_request:
    paths:
      - 'products/**/*-details.yml'
  push:
    branches:
      - master
    paths:
      - 'products/**/*-details.yml'

jobs:
  validate-product-details:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    permissions:
      contents: read
      issues: read
      pull-requests: write

    steps:
      - name: Optimized checkout for large repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Changed from 1 to get full history for proper diff
          sparse-checkout: |
            .github/workflows/
            scripts/
            products/
          sparse-checkout-cone-mode: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1'
          bundler-cache: false

      - name: Install dependencies
        run: |
          gem install yaml psych net-http uri

      - name: Get changed product files
        id: changed-files
        run: |
          echo "üîç Debug: Event name is ${{ github.event_name }}"
          echo "üîç Debug: Base ref is ${{ github.base_ref }}"
          echo "üîç Debug: Head ref is ${{ github.head_ref }}"
          
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For pull requests, get files changed in this PR
            echo "üîç Debug: Fetching base branch origin/${{ github.base_ref }}"
            git fetch origin ${{ github.base_ref }}
            
            echo "üîç Debug: Available branches:"
            git branch -a
            
            echo "üîç Debug: Getting changed files between origin/${{ github.base_ref }} and HEAD"
            ALL_CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD || git diff --name-only HEAD~10..HEAD)
            echo "üîç Debug: All changed files:"
            echo "$ALL_CHANGED"
            
            CHANGED_FILES=$(echo "$ALL_CHANGED" | grep 'products/.*-details\.yml$' || true)
          else
            # For push to master, get files in the last commit
            echo "üîç Debug: Getting files from last commit"
            ALL_CHANGED=$(git diff --name-only HEAD~1 HEAD)
            echo "üîç Debug: All changed files:"
            echo "$ALL_CHANGED"
            
            CHANGED_FILES=$(echo "$ALL_CHANGED" | grep 'products/.*-details\.yml$' || true)
          fi
          
          echo "üîç Debug: Product details files found:"
          echo "$CHANGED_FILES"
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No product details files changed"
            echo "changed_files=" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Changed product details files:"
            echo "$CHANGED_FILES"
            # Convert to space-separated list for easier processing
            FILES_LIST=$(echo "$CHANGED_FILES" | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//g' | sed 's/ *$//g')
            echo "üîç Debug: Files list for output: '$FILES_LIST'"
            echo "changed_files=$FILES_LIST" >> $GITHUB_OUTPUT
          fi

      - name: Validate changed product files
        id: validation
        if: steps.changed-files.outputs.changed_files != ''
        continue-on-error: true  # Continue even if validation fails so we can post comments
        run: |
          FILES_TO_VALIDATE="${{ steps.changed-files.outputs.changed_files }}"
          echo "üîç Debug: Files to validate: '$FILES_TO_VALIDATE'"
          
          if [ -z "$FILES_TO_VALIDATE" ]; then
            echo "‚ùå No files to validate (empty list)"
            exit 1
          fi
          # Create validation script
          cat > validate_links.rb << 'EOF'
          #!/usr/bin/env ruby
          require 'yaml'
          require 'net/http'
          require 'uri'
          require 'json'

          class ProductLinkValidator
            # Template defaults that should be ignored
            TEMPLATE_DEFAULTS = {
              'manifest_url' => 'https://github.com/department-of-veterans-affairs/vets-website/blob/main/src/applications/[app-name]/manifest.json',
              'project_board' => 'https://',
              'research_repo' => 'https://github.com/department-of-veterans-affairs/va.gov-research-repository/issues',
              'github-label' => 'Product label'
            }.freeze

            def initialize(github_token)
              @github_token = github_token
              @errors = []
              @warnings = []
            end

            def validate_file(file_path)
              puts "üîç Validating #{file_path}..."
              
              unless File.exist?(file_path)
                @errors << "‚ùå File not found: #{file_path}"
                return
              end

              begin
                content = YAML.safe_load(File.read(file_path))
                validate_yaml_structure(content, file_path)
                validate_links(content, file_path)
                validate_github_label(content, file_path)
              rescue Psych::SyntaxError => e
                @errors << "‚ùå YAML syntax error in #{file_path}: #{e.message}"
              rescue => e
                @errors << "‚ùå Error processing #{file_path}: #{e.message}"
              end
            end

            def validate_yaml_structure(content, file_path)
              unless content.is_a?(Hash)
                @errors << "‚ùå #{file_path}: YAML content must be a hash/object"
                return
              end

              required_fields = %w[name entry_name description team status]
              missing_fields = required_fields.select do |field|
                !content.key?(field) || content[field].nil? || content[field].to_s.strip.empty?
              end

              unless missing_fields.empty?
                @errors << "‚ùå #{file_path}: Missing required fields: #{missing_fields.join(', ')}"
              end

              # Check for template placeholders
              placeholder_checks = {
                'name' => 'Product Display Name',
                'entry_name' => 'manifest-entry-name',
                'description' => 'Product description',
                'team' => 'team-name'
              }

              placeholder_checks.each do |field, placeholder|
                if content[field] == placeholder
                  @errors << "‚ùå #{file_path}: Field '#{field}' contains template placeholder: #{placeholder}"
                end
              end
            end

            def validate_links(content, file_path)
              # Validate manifest_url
              if content['manifest_url'] && content['manifest_url'] != TEMPLATE_DEFAULTS['manifest_url']
                validate_url(content['manifest_url'], 'manifest_url', file_path)
              end

              # Validate measurement URLs
              if content['measurement'].is_a?(Hash)
                measurement = content['measurement']
                
                if measurement['project_board'] && measurement['project_board'] != TEMPLATE_DEFAULTS['project_board']
                  validate_url(measurement['project_board'], 'project_board', file_path)
                end

                if measurement['research_repo'] && measurement['research_repo'] != TEMPLATE_DEFAULTS['research_repo']
                  validate_url(measurement['research_repo'], 'research_repo', file_path)
                end

                # Validate other measurement URLs
                %w[datadog_dashboard domo_dashboard google_analytics metrics_dashboard].each do |field|
                  if measurement[field] && !measurement[field].match?(/^https?:\/+\.\.\./) && !measurement[field].strip.empty?
                    validate_url_format(measurement[field], field, file_path)
                  end
                end
              end

              # Validate production and staging URLs
              if content['urls'].is_a?(Hash)
                %w[production staging].each do |env|
                  if content['urls'][env] && !content['urls'][env].match?(/^https?:\/+\.\.\./) && !content['urls'][env].strip.empty?
                    validate_url_format(content['urls'][env], "urls.#{env}", file_path)
                  end
                end
              end
            end

            def validate_github_label(content, file_path)
              github_label = content['github-label']
              return unless github_label && github_label != TEMPLATE_DEFAULTS['github-label']

              puts "üè∑Ô∏è  Checking GitHub label: #{github_label}"
              
              # Check if label exists in the repository
              begin
                encoded_label = URI.encode_www_form_component(github_label)
                api_url = "https://api.github.com/repos/department-of-veterans-affairs/va.gov-team/labels/#{encoded_label}"
                response = github_api_request(api_url)
                
                if response.code == '200'
                  puts "‚úÖ GitHub label '#{github_label}' exists"
                elsif response.code == '404'
                  @warnings << "‚ö†Ô∏è  #{file_path}: GitHub label '#{github_label}' does not exist in va.gov-team repository"
                else
                  @warnings << "‚ö†Ô∏è  #{file_path}: Could not verify GitHub label '#{github_label}' (HTTP #{response.code})"
                end
              rescue => e
                @warnings << "‚ö†Ô∏è  #{file_path}: Error checking GitHub label '#{github_label}': #{e.message}"
              end
            end

            def validate_url_format(url, field_name, file_path)
              begin
                uri = URI.parse(url)
                unless uri.scheme && %w[http https].include?(uri.scheme)
                  @errors << "‚ùå #{file_path}: #{field_name} must be a valid HTTP/HTTPS URL: #{url}"
                  return false
                end
                
                unless uri.host
                  @errors << "‚ùå #{file_path}: #{field_name} must have a valid hostname: #{url}"
                  return false
                end
                
                # Additional validation for specific field types
                case field_name
                when 'manifest_url'
                  unless url.include?('github.com') && url.include?('manifest.json')
                    @errors << "‚ùå #{file_path}: manifest_url should be a GitHub URL pointing to manifest.json: #{url}"
                    return false
                  end
                when 'research_repo'
                  unless url.include?('github.com')
                    @warnings << "‚ö†Ô∏è  #{file_path}: research_repo should typically be a GitHub URL: #{url}"
                  end
                end
                
                true
              rescue URI::InvalidURIError
                @errors << "‚ùå #{file_path}: #{field_name} contains invalid URL: #{url}"
                false
              end
            end

            def validate_url(url, field_name, file_path)
              validate_url_format(url, field_name, file_path)
              puts "‚úÖ URL format valid: #{url}"
            end

            # Remove the unused validation methods since we're only doing format validation
            def github_api_request(url)
              uri = URI.parse(url)
              http = Net::HTTP.new(uri.host, uri.port)
              http.use_ssl = true
              http.open_timeout = 10
              http.read_timeout = 10
              
              path = uri.path
              path += "?#{uri.query}" if uri.query
              
              request = Net::HTTP::Get.new(path)
              request['Authorization'] = "token #{@github_token}"
              request['Accept'] = 'application/vnd.github.v3+json'
              request['User-Agent'] = 'VA.gov Product Validator'
              
              http.request(request)
            end

            def report_results
              puts "\nüìä Validation Results:"
              puts "Errors: #{@errors.length}"
              puts "Warnings: #{@warnings.length}"
              
              unless @errors.empty?
                puts "\n‚ùå ERRORS:"
                @errors.each { |error| puts error }
              end
              
              unless @warnings.empty?
                puts "\n‚ö†Ô∏è  WARNINGS:"
                @warnings.each { |warning| puts warning }
              end
              
              @errors.empty?
            end
          end

          # Main execution
          if ARGV.empty?
            puts "Usage: ruby validate_links.rb <file1> [file2] ..."
            exit 1
          end

          github_token = ENV['GITHUB_TOKEN']
          unless github_token
            puts "‚ùå GITHUB_TOKEN environment variable not set"
            exit 1
          end

          validator = ProductLinkValidator.new(github_token)
          
          ARGV.each do |file_path|
            validator.validate_file(file_path)
          end
          
          success = validator.report_results
          exit(success ? 0 : 1)
          EOF

          chmod +x validate_links.rb
          
          # Run validation on changed files
          echo "üöÄ Starting validation..."
          
          # Capture validation output to a file for PR comment
          VALIDATION_OUTPUT_FILE="validation_results.txt"
          
          # Run validation and capture output
          if ruby validate_links.rb $FILES_TO_VALIDATE > "$VALIDATION_OUTPUT_FILE" 2>&1; then
            echo "‚úÖ Validation passed"
            echo "validation_status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Validation failed"
            echo "validation_status=failure" >> $GITHUB_OUTPUT
          fi
          
          # Always show the results
          echo "üìä Validation Results:"
          cat "$VALIDATION_OUTPUT_FILE"
          
          # Store results for PR comment (properly handle multiline output)
          {
            echo "validation_output<<EOF"
            cat "$VALIDATION_OUTPUT_FILE"
            echo "EOF"
          } >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run existing product validation
        id: existing-validation
        if: steps.changed-files.outputs.changed_files != ''
        continue-on-error: true
        run: |
          FILES_TO_VALIDATE="${{ steps.changed-files.outputs.changed_files }}"
          
          # Run the existing validation script for comparison
          if [ -f "scripts/manifest/validate_products.rb" ]; then
            echo "üîß Running existing product validation..."
            
            EXISTING_OUTPUT_FILE="existing_validation_results.txt"
            
            for file in $FILES_TO_VALIDATE; do
              if [ -f "$file" ]; then
                product_name=$(basename "$file" .yml | sed 's/-details$//')
                echo "üîç Validating product: $product_name (from file: $file)"
                ruby scripts/manifest/validate_products.rb --product "$product_name" --verbose >> "$EXISTING_OUTPUT_FILE" 2>&1 || true
              fi
            done
            
            if [ -f "$EXISTING_OUTPUT_FILE" ]; then
              echo "üìä Existing Validation Results:"
              cat "$EXISTING_OUTPUT_FILE"
              
              # Store results for PR comment (properly handle multiline output)
              {
                echo "existing_validation_output<<EOF"
                cat "$EXISTING_OUTPUT_FILE"
                echo "EOF"
              } >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è  Existing validation script not found, skipping"
            echo "existing_validation_output=Existing validation script not found" >> $GITHUB_OUTPUT
          fi

      - name: Comment on PR with validation results
        if: always() && github.event_name == 'pull_request' && steps.changed-files.outputs.changed_files != ''
        uses: actions/github-script@v7
        with:
          script: |
            const changedFiles = "${{ steps.changed-files.outputs.changed_files }}".split(' ').filter(f => f.trim().length > 0);
            const validationStatus = "${{ steps.validation.outputs.validation_status }}";
            
            // Use environment variables to safely pass multiline content
            const validationOutput = process.env.VALIDATION_OUTPUT || 'No validation output captured';
            const existingValidationOutput = process.env.EXISTING_VALIDATION_OUTPUT || '';
            
            // Determine overall status and icon
            const statusIcon = validationStatus === 'success' ? '‚úÖ' : '‚ùå';
            const statusText = validationStatus === 'success' ? 'PASSED' : 'FAILED';
            
            // Build comment content
            let comment = `## ${statusIcon} Product Details Validation ${statusText}\n\n`;
            comment += `**Files Validated:**\n`;
            comment += changedFiles.map(f => `- \`${f}\``).join('\n') + '\n\n';
            comment += `### üîç Validation Results\n\n`;
            comment += '```\n';
            comment += validationOutput;
            comment += '\n```\n\n';

            // Add existing validation results if available
            if (existingValidationOutput && existingValidationOutput !== 'Existing validation script not found') {
              comment += `### üîß Legacy Validation Results\n\n`;
              comment += '```\n';
              comment += existingValidationOutput;
              comment += '\n```\n\n';
            }

            // Add footer with validation details
            comment += `---\n\n`;
            comment += `**Validation Checks Performed:**\n`;
            comment += `- ‚úÖ YAML syntax and required fields\n`;
            comment += `- üîó URL format validation for all links\n`;
            comment += `- üè∑Ô∏è GitHub label existence in va.gov-team repository\n`;
            comment += `- üìã Template placeholder detection\n\n`;
            
            if (validationStatus === 'failure') {
              comment += `‚ö†Ô∏è **Action Required:** Please fix the validation errors above before merging.`;
            } else {
              comment += `üéâ **All checks passed!** This PR is ready for review.`;
            }

            // Post or update comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            // Look for existing validation comment
            const existingComment = comments.find(comment => 
              comment.body.includes('Product Details Validation') && 
              comment.user.login === 'github-actions[bot]'
            );

            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
              console.log('Updated existing validation comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              console.log('Created new validation comment');
            }
        env:
          VALIDATION_OUTPUT: ${{ steps.validation.outputs.validation_output }}
          EXISTING_VALIDATION_OUTPUT: ${{ steps.existing-validation.outputs.existing_validation_output }}
